"""
Analyzer for the `two-fer` exercise.
"""
import ast
from pylint import epylint as lint
from pathlib import Path

from common import Analysis, BaseComments


class Comments(BaseComments):
    NO_MODULE = ("general", "no_module")
    NO_METHOD = ("two-fer", "no_method")
    MALFORMED_CODE = ("general", "malformed_code")
    SIMPLE_CONCAT = ("two-fer", "simple_concat")
    NO_DEF_ARG = ("two-fer", "no_def_arg")
    CONDITIONALS = ("two-fer", "conditionals")
    NO_RETURN = ("two-fer", "no_return")
    WRONG_DEF_ARG = ("two-fer", "wrong_def_arg")
    PERCENT_FORMATTING = ("two-fer", "percent_formatting")


def analyze(path: Path):
    """
    Analyze the user's Two Fer solution to give feedback and disapprove malformed solutions. Outputs a JSON that
    conforms to Exercism's Auto-Mentor project interface.

    :return: A tuple containing a list of feedback comments as its first entry, a bool indicating whether a
        solution should be approved as its second entry, a list of comments generated by Pylint as its third entry,
        and a 'status' string corresponding to the value of the status key in the generated JSON, as its fourth
        entry.
    """
    output_file = path.parent.joinpath("analysis.json")

    # Input file
    try:
        user_solution = path.read_text()
    except OSError as err:
        # If the proper file cannot be found, disapprove this solution
        return Analysis.disapprove_with_comment([Comments.NO_MODULE]).dump(output_file)

    try:
        # Parse file to abstract syntax tree
        tree = ast.parse(user_solution)
    except Exception:
        # If ast.parse fails, the code is malformed and this solution is disapproved
        return Analysis.disapprove_with_comment([Comments.MALFORMED_CODE]).dump(
            output_file
        )

    # List of comments to return at end, each comment is a string
    comments = []

    # Whether to approve the user's solution based on analysis. Note that this only denotes if it's POSSIBLE for the
    # user's solution to be approved; just because the user didn't submit something that automatically makes it get
    # disapproved, like an empty file or missing method header, doesn't mean it's actually correct. Final assessment
    # of the user's solution must be done by a mentor (unless the solution is one of the optimal solutions we check for).
    approve = True
    # Does the solution have a method called two_fer?
    has_method = False
    # Does the solution correctly use a default argument?
    uses_def_arg = False
    # Does the solution have a return value?
    has_return = False
    # Does the solution use str.format?
    uses_format = False
    # Does the solution use f-strings?
    uses_f_string = False

    for node in ast.walk(tree):

        # Search for method called two_fer
        if isinstance(node, ast.FunctionDef):
            has_method = node.name == "two_fer"

        # Search for use of string concatenation with + operator
        elif isinstance(node, ast.Add) and Comments.SIMPLE_CONCAT not in comments:
            comments.append(Comments.SIMPLE_CONCAT)

        # Search for use of default arguments
        elif isinstance(node, ast.arguments):
            if node.defaults:
                uses_def_arg = True
                # Search for use of incorrect default argument
                try:
                    if (
                        node.defaults[0].s != "you"
                        and Comments.WRONG_DEF_ARG not in comments
                    ):
                        comments.append(Comments.WRONG_DEF_ARG)
                except Exception:
                    if Comments.WRONG_DEF_ARG not in comments:
                        comments.append(Comments.WRONG_DEF_ARG)

        # Search for use of unnecessary conditionals
        elif isinstance(node, ast.If) and Comments.CONDITIONALS not in comments:
            comments.append(Comments.CONDITIONALS)

        # Search for use of %-formatting
        elif isinstance(node, ast.Mod) and Comments.PERCENT_FORMATTING not in comments:
            comments.append(Comments.PERCENT_FORMATTING)

        # Search for return
        elif isinstance(node, ast.Return):
            has_return = True

        # Search for use of str.format
        elif isinstance(node, ast.Call):
            try:
                uses_format = node.func.attr == "format"
            except Exception:
                pass

        # Search for use of f-strings
        try:
            if isinstance(node, ast.FormattedValue):
                uses_f_string = True
        except AttributeError:
            pass  # Fail if python version is too low

    if not has_method:
        comments.append(Comments.NO_METHOD)
        approve = False

    if not uses_def_arg:
        comments.append(Comments.NO_DEF_ARG)

    if not has_return:
        comments.append(Comments.NO_RETURN)
        approve = False

    # Use Pylint to generate comments for code, e.g. if code follows PEP8 Style Convention
    pylint_stdout, _ = lint.py_run(str(path), return_std=True)
    pylint_comments = [pylint_stdout.getvalue()]

    # Handle a known optimal solution
    if approve and (not comments) and (uses_format or uses_f_string):
        return Analysis.approve_as_optimal(comments, pylint_comments).dump(output_file)

    # Handle a known inadequate solution
    if not approve:
        return Analysis.disapprove_with_comment(comments, pylint_comments).dump(
            output_file
        )

    # In all other cases refer to the Mentor
    return Analysis.refer_to_mentor(comments, pylint_comments, approve=approve).dump(
        output_file
    )
